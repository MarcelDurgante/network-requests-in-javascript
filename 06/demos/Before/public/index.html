<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="img/favicon.ico" />
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.3/font/bootstrap-icons.css">
    <link rel="stylesheet" href="css/styles.css">
    <script src="js/helpers.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Globoticket</title>
  </head>
  <body>
    <div id="root">
        <nav class="navbar navbar-expand navbar-dark fixed-top bg-dark">
            <div class="container-fluid">
                <div class="collapse navbar-collapse">
                    <ul class="navbar-nav me-auto ms-3 mb-2 mb-lg-0">
                        <li class="nav-item">
                            <a href="./" class="navbar-brand"><img src="img/logo.png" alt="Globoticket logo" /></a>
                        </li>
                    </ul>
                </div>
                <div class="collapse navbar-collapse">
                    <ul class="navbar-nav ms-auto me-5 mb-2 mb-lg-0">
                        <li class="nav-item">
                            <a href="./cart" class="nav-link">
                                <span class="bi bi-cart-plus-fill text-white font-xxlarge"></span>
                                <span class="font-upper font-bold text-white ms-4">
                                    <span class="font-xxlarge align-middle" id="spanTickets">0</span>
                                    <span class="align-middle ms-2">ticket(s)</span>
                                </span>
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>
        <div class="container" id="eventtable">
            <div class="container">
                <table class="table mt-5">
                    <thead>
                        <tr>
                            <th scope="col"></th>
                            <th scope="col">Date</th>
                            <th scope="col">Name</th>
                            <th scope="col">Artist</th>
                            <th scope="col">Price</th>
                            <th scope="col"></th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    <script>
        /* WebSockets: 
        
        WebSockets are a bidirectional communication protocol used for exchanging data between a client and a server. Unlike HTTP, which is request-response based and closes the connection after each exchange, WebSockets allow continuous data transmission between the two parties. Here's a summary of how WebSockets work:

            Establishing Connection: The client initiates a connection with the server, typically through a web server, by sending an HTTP request using a specified port (e.g., port 80 or 443). Within this request, the client includes an "upgrade" header with "websocket" as the value, indicating its desire to use WebSockets for communication.

            Handshake: After receiving the client's request, the server and client perform a handshake. During this process, the client sends a random key that is Base64 encoded. If the server is capable of accepting a WebSocket connection, it responds with an HTTP 101 status code known as "Switching Protocols." It also includes the headers "Upgrade: websocket" and "Connection: Upgrade" in its response.

            Security Verification: To ensure the authenticity of the server's response, the server appends a GUID (Globally Unique Identifier) to the client's security key and calculates a SHA hash for it. This hash is returned to the client, confirming that the response came from the server.

            Bidirectional Communication: Once the handshake is complete, a bidirectional communication channel is established between the client and server. They can now exchange data in real-time without the need for the client to continuously send requests.

        In various scenarios, WebSockets provide an efficient way to transmit data from the server to the client continuously, eliminating the need for repeated polling of data through traditional HTTP requests.
        
        */

        /* WebSockets JavaScript implementation key steps: 
        
        WebSockets are well-supported in major browsers, allowing clients to use JavaScript for WebSockets communication with supporting servers. When using npm, two primary packages, 'ws' and 'websocket,' offer both client and server libraries. In a typical JavaScript implementation, here's a summary of key steps:

            Instantiating WebSocket: Start by creating an instance of the WebSocket class, specifying a URL to connect to the WebSocket endpoint. URLs typically begin with 'ws://' for WebSocket or 'wss://' for WebSocket Secure, akin to HTTP and HTTPS.

            Handling Events:

                Open Event: After the connection is established, the 'open' event is fired. You can set up an event handler for this event to perform actions when the connection is ready.
                Sending Messages: You can use the 'send' method to send messages from the client to the server once the connection is established.
                Message Event: When the server sends data to the client, the 'message' event is triggered. You can set up an event handler for this event to process incoming data.
                Closing Connection: The connection can be closed actively from the client side or by the server, such as in the case of a server crash. You'll receive notifications when the connection is closed.
                Error Handling: There's also an 'error' event available for handling errors that may occur during WebSocket communication.

        This JavaScript API provides the foundation for bidirectional communication between clients and servers using WebSockets, making it suitable for various applications, including the Globoticket application.
        
        */
        let controllers = [];

        fetch('api/events')
            .then(response => {
                if (response.status !== 200) {
                    showError('Something went wrong.');
                }
                return response.json();
            })
            .then(events => {
                showEvents(events);
                events.forEach(async event => {
                    let controller = new AbortController();
                    controllers.push(controller);
                    const response = await fetch(`api/cover/${event.id}`, {
                        signal: controller.signal
                    });

                    const reader = response.body.getReader();
                    const total = response.headers.get('Content-Length') || 0;

                    let chunks = [];
                    let received = 0;
                    while (true) {
                        const { done, value } = await reader.read();
                        if (value) {
                            chunks.push(value);
                            received += value.length;

                            showProgress(total === 0 ? 'N/A' : Math.ceil(100*received/total) + ' %', event.id);
                        }

                        if (done) break;
                    }
                    removeProgress(event.id);
                    
                    var img = decodeChunks(chunks);
                    showImage(img, event.id);
                });
                const ws = new WebSocket('ws://localhost:3000'); // create an instance of WebSocket, and URL will be ws for WebSockets and then localhost port 3000
                ws.onmessage = (e) => { // onmessage, and we set it to a function that receives event data or event arguments. And the data property of those contains the message from the server. The message from the server, as you've just seen, in the browser is a JSON string. So basically, we would like to parse that JSON string. And remember, we have that helper JavaScript function, updateCart, which we've used before. Now updateCart usually expects the full shopping cart, so all of the articles with their quantities. But what the server sends us is good enough for the purpose of updating the UI because the server just sends the info quantity of 42 for 42 items in total. So this is actually good enough for our purposes.
                    updateCart(JSON.parse(e.data));
                }
            });

        function abort() {
            controllers.forEach(controller => controller.abort());
        }

        function addToCart(id, quantity) {
            fetch('api/cart', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ id: id, quantity: quantity})
            })
                .then(response => {
                    if (response.status === 200) {
                        fetch('api/cart')
                            .then(response => response.json())
                            .then(cart => updateCart(cart));
                    }
                });
        }
    </script>
  </body>
</html>
