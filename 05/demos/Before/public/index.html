<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <link rel="icon" href="img/favicon.ico" />
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.3/font/bootstrap-icons.css">
    <link rel="stylesheet" href="css/styles.css">
    <script src="js/helpers.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Globoticket</title>
</head>

<body>
    <div id="root">
        <nav class="navbar navbar-expand navbar-dark fixed-top bg-dark">
            <div class="container-fluid">
                <div class="collapse navbar-collapse">
                    <ul class="navbar-nav me-auto ms-3 mb-2 mb-lg-0">
                        <li class="nav-item">
                            <a href="./" class="navbar-brand"><img src="img/logo.png" alt="Globoticket logo" /></a>
                        </li>
                    </ul>
                </div>
                <div class="collapse navbar-collapse">
                    <ul class="navbar-nav ms-auto me-5 mb-2 mb-lg-0">
                        <li class="nav-item">
                            <a href="./cart" class="nav-link">
                                <span class="bi bi-cart-plus-fill text-white font-xxlarge"></span>
                                <span class="font-upper font-bold text-white ms-4">
                                    <span class="font-xxlarge align-middle" id="spanTickets">0</span>
                                    <span class="align-middle ms-2">ticket(s)</span>
                                </span>
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>
        <div class="container" id="eventtable">
            <div class="container">
                <table class="table mt-5">
                    <thead>
                        <tr>
                            <th scope="col"></th>
                            <th scope="col">Date</th>
                            <th scope="col">Name</th>
                            <th scope="col">Artist</th>
                            <th scope="col">Price</th>
                            <th scope="col"></th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    <script>
        /* Timeouts explanation (see XMLHttpRequest - Request Timeouts support image): 
        
        As you have seen so far, the XMLHttpRequest API is rather limited. I mean, we can send the HTTP requests, we can read out the responses, but we don't have many extra features. Well, we can set headers. We could also actually read out response headers. But there's one feature embedded in that API, and that's a built‑in timeout mechanism. 
        
        So, when we have an XMLHttpRequest instance, we can set its timeout property, and here I set it to 1000. That is the number of milliseconds, so that means 1 second. What does that mean? We send the request then, and the request takes a while until the server sends it or is done sending it. If that happens before those 1000 ms have passed after sending the request, the load event is triggered. So whatever we set xhr.onload to will be called and run. 
        
        If, however, it takes the server longer than 1 second to reply to our request, the timeout event is fired. So if we set xhr.ontimeout to a handler function, that handler function will now be called. So this is a way of doing error handling for long‑running requests.
        
        */
       /* Implementation steps: 
       
       In the JavaScript code, we then set the timeout property to, say, 1000, so 1000 ms, 1 second. Remember the artificial delay in the API is between 0 and 2 seconds. So in about 50% of cases, the API is quick enough, and in the other 50% of cases, it is not. 
       
       So we can set up the ontimeout event handler, and there we just output an error message. 
       
       We have the showError helper function and then maybe Request timed out! as an appropriate message, and that's it. 
       
       The only thing remaining is, of course, that we are actually calling the slow API and not the good one, so events‑slow, and then we verify the behavior in the browser. 
       
       */
        const xhr = new XMLHttpRequest();
        xhr.open('GET', 'api/events-slow', true); // 1. calling the slow API and not the good one
        xhr.timeout = 1000; // 2. set the timeout property to 1000, so 1000 ms, 1 second
        xhr.onload = () => {
            const events = JSON.parse(xhr.responseText);
            showEvents(events);
        };
        xhr.ontimeout = () => { // 3.  set up the ontimeout event handler to output an error message
            showError('Request timed out!'); // 4. showError helper function passing 'Request timed out!' as argument that will be displayed as the error message
        };
        xhr.send(null);

        function addToCart(id, quantity) { 
            const xhrPOST = new XMLHttpRequest(); 
            xhrPOST.open('POST', 'api/cart', true);
            xhrPOST.onload = () => { 
                const xhrGET = new XMLHttpRequest(); 
                xhrGET.open('GET', 'api/cart', true); 
                xhrGET.onload = () => { 
                    const cart = JSON.parse(xhrGET.responseText); 
                    updateCart(cart); 
                };
                xhrGET.send(null);
            };
            xhrPOST.setRequestHeader('Content-Type', 'application/json'); 
            xhrPOST.send(JSON.stringify({ id: id, quantity: quantity })); 
        }
        /* output: 
        
        So let's go to the home page. And after a short delay, we get a list of events. Let's refresh. It takes a while, and now the request timed out. In the UI we se the error message.

        Summary:

        And this was possible with just a few lines of code. And this is apart from sending the actual requests, the other main feature, so to speak of XMLHttpRequest. But of course, in retrospect, working with a promise‑based API such as the Fetch API or even the API that Axios provides is probably the more convenient approach. And this concludes our coverage of sending HTTP requests to a server from JavaScript using different techniques. However, there's one more thing I'd like to talk about, and that covers high performance bidirectional communication with a server using something called WebSockets. That's up next.
        
        */
    </script>
</body>

</html>